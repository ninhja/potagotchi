<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<!-- <link rel=stylesheet href="css/base.css"/> -->
		<title>Pot Shapes</title>
		<style>
			@font-face {
				font-family: 'inconsolata';
				src: url('files/inconsolata.woff') format('woff');
				font-weight: normal;
				font-style: normal;
			}

			body {
				margin:0;
				font-family: 'inconsolata';
				font-size: 18px;
				line-height: 18px;
				background-color: #ffffff;
				margin: 0px;
				overflow: hidden;
			}

			canvas {
				width: 100%;
				height: 100%;
				background-color: #FA8072;
		 }

		</style>
	</head>
	<body>

		<script src="build/three.js"></script>
		<script src='examples/js/libs/dat.gui.min.js'></script>
		<script src="examples/js/controls/OrbitControls.js"></script>
		<script src="ThreeCSG.js"></script>
		<script>

			// Global control variables
			var gui, scene, camera, renderer, controls, lights;

			// Planter variables
			var root; // the base Object3D shape of the planter.
			var geometry; // the geometry of the root and its children:
										//{BoxGeometry, CylinderGeometry, SphereGeometry, etc.}
			var geomType; // a String that tells you the type of geometry
			var material = new THREE.MeshLambertMaterial( {color: 0x69ff00} ); //0x69ff00 0x47ff00

			function init() {

				// SCENE
				scene = new THREE.Scene();

				// CAMERA
				var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
				var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
				camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR );
				camera.position.set(60, 170, 0 );
				scene.add( camera );

				// RENDERER
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
				document.body.appendChild( renderer.domElement );

				// ORBIT CONTROLS
				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 0, 0 );
				controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				controls.dampingFactor = 0.35;
				controls.screenSpacePanning = false;
				controls.maxDistance = 500;
				controls.maxPolarAngle = Math.PI / 2;

				// AXES HELPER
				// The X axis is red. The Y axis is green. The Z axis is blue.
				var axes = new THREE.AxesHelper(400);
				scene.add(axes);

				// LIGHTS
				var light = new THREE.PointLight( 0xffffff, 1, 0 );
				light.position.set( 0, 80, 40 );
				light.castShadow = true;
				light.shadow.radius = 8;
				scene.add( light );
				scene.add( new THREE.AmbientLight( 0xffffff, 0.8 ) ); // I add AmbientLight to lighten the shadows

				// SUN
				var sunGeometry = new THREE.SphereGeometry( 7, 16, 16 );
				var innerSunGeometry = new THREE.SphereGeometry( 5, 16, 16 );
				var sunMaterial = new THREE.MeshBasicMaterial( { color: 0xffee71, transparent: true, opacity: 0.5 } );
				var innerSunMaterial = new THREE.MeshBasicMaterial( { color: 0xffd600 } );
				var sun = new THREE.Mesh( sunGeometry, sunMaterial );
				var innerSun = new THREE.Mesh( innerSunGeometry, innerSunMaterial );
				sun.position.set( 0, 80, 40 );
				innerSun.position.set( 0, 80, 40 );
				scene.add(sun);
				scene.add(innerSun);

				// FLOOR
				// var floorTexture = new THREE.ImageUtils.loadTexture( 'images/checkerboard.jpg' );
				// floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
				// floorTexture.repeat.set( 10, 10 );
				// var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
				var floorMaterial = new THREE.MeshLambertMaterial( { color: 0x2DA100 } );
				var floorGeometry = new THREE.CylinderGeometry(50, 50, 2, 64, 64);
				var floor = new THREE.Mesh(floorGeometry, floorMaterial);
				floor.position.y = -6;
				floor.receiveShadow = true;
				scene.add(floor);

				// SKYBOX/FOG 	#FA8072
				var skyBoxGeometry = new THREE.BoxGeometry( 800, 800, 800 );
				var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0xa7d3ff, side: THREE.BackSide } );
				var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
				scene.add(skyBox);
				// scene.fog = new THREE.FogExp2( 0x75baff, 0.007 );

				// RESIZE WINDOW
				window.addEventListener( 'resize', function () {
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
					renderer.setSize( window.innerWidth, window.innerHeight );
				}, false );

				// GUI
				setupDatGui();

			}

			// creates the root of the pot (the base shape)
			// args: geom (type = String) is the seed shape that the user specified in gui.
			function createRoot( geom ) {
				geomType = geom;

				// choose the type of geometry, based on what the user specified in gui
				geometry = (function(geomType) {
					switch(geomType) {
						case 'cube':
							return new THREE.BoxGeometry( 10, 10, 10 );
						case 'cylinder':
							return new THREE.CylinderGeometry( 10, 10, 10, 32, 32 );
						case 'sphere':
							return new THREE.SphereGeometry( 10, 32, 32);
					}
				})(geomType);

				// create the root object. This will be the base of the planter.
				root = new THREE.Mesh( geometry, material );
				root.position.set( 0, 0, 0 );
				root.castShadow = true; //default is false
				root.receiveShadow = false; //default
				scene.add(root);

				// shell(root, 2);
			}

			// creates the child shape to add to its parent shape
			function createChild(parent) {
				var child = new THREE.Mesh( geometry, material );
				var parentSize = getSize(parent);

				// position the child in a random so that it overlaps with its parent.
				child.position.set(getRandomInt(parent.position.x, parentSize),
													 getRandomInt(parent.position.y, parentSize),
													 getRandomInt(parent.position.z, parentSize));
				child.castShadow = true; //default is false
				child.receiveShadow = false; //default
				addChild(parent, child);
				// shell(child, 2);
			}

			// adds the child shape to its parent, then adds child to scene
			function addChild(parent, child) {
				parent.add(child);
			}

			function shell(object, wallThickness) {
				var outerSize = getSize(object);
				var innerObject = (function(geomType) {
					var innerSize;
					switch(geomType) {
						case 'cube':
							innerSize = outerSize - (2 * wallThickness)
							return new THREE.BoxGeometry( innerSize, innerSize, innerSize );
						case 'cylinder':
							innerSize = outerSize - wallThickness
							return new THREE.CylinderGeometry( innerSize, innerSize, innerSize, 32, 32 );
						case 'sphere':
							innerSize = outerSize - wallThickness
							return new THREE.SphereGeometry( innerSize, 32, 32);
					}
				})(geomType);

				var outerMesh = new THREE.Mesh(object.geometry);
				var outerBSP = new ThreeBSP(outerMesh);

				var innerMesh = new THREE.Mesh(innerObject);
				var innerBSP = new ThreeBSP(innerMesh);

				var objectX = object.position.x;
				var objectY = object.position.y;
				var objectZ = object.position.z;
				innerMesh.position.set(objectX, objectY + wallThickness, objectZ);

				var shelledBSP = outerBSP.subtract(innerBSP);
				var shelledMesh = shelledBSP.toMesh(material);

				scene.add(shelledMesh);
				// return shelledMesh
			}

			// helper function for creating a new object.
			// turns the solid geometry into a shell, with specified wall thickness
			function getSize(object) {
				switch(geomType) {
					case 'cube':
						return object.geometry.parameters.width;
					case 'cylinder':
						return object.geometry.parameters.radiusTop;
					case 'sphere':
						return object.geometry.parameters.radius;
				}
			}

			// position (x), length of geometry
			function getRandomInt(pos, dim) {
				var diff = dim / 3; // add 1 if inclusive
				var min = pos - (dim / 2);
				var max = pos + (dim / 6);
				var n = Math.floor((Math.random() * (max - diff)) +1);
				if ((n >= pos - (dim / 6)) && (n <= pos + (dim / 6))) {
					n += diff;
				}
				return n;
			}

			function setupDatGui() {
				gui = new dat.GUI({name: 'My GUI'});

				// Options to be added to the GUI
				var options = {
				  seedShape: 'cube',
					createRoot: function() {
						if (root != null) {
							alert("You already have a planter growing! Uproot it to plant a new one.");
						} else {
							createRoot(options.seedShape);
						}
				  },
				  addChild: function() {
						if (root == null) {
							alert("Plant your seed first!");
						} else {
							createChild(root);
						}
				  },
					uprootPlanter: function() {
						scene.remove(root);
						root = null;
					}
				};

				// DAT.GUI Related Stuff
				// var seeds = gui.addFolder('Seed Shape');
				// seeds.add(options.seeds, 'cube').listen();
				// seeds.add(options.seeds, 'sphere').listen();
				// seeds.add(options.seeds, 'cylinder').listen();
				// seeds.open();

				var seedShape = gui.add(options, 'seedShape', [ 'cube', 'cylinder', 'sphere' ] ).name('Seed shape');

				gui.add(options, 'createRoot').name('Plant a new seed');
				gui.add(options, 'addChild').name('Grow planter');
				gui.add(options, 'uprootPlanter').name('Uproot planter');
			}

			function animate() {
				requestAnimationFrame( animate );
				controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
				render();
			}

			function render() {
				renderer.render( scene, camera );
			}

			function alertMessage( message ) {
				alert( message );
			}

			init();
			animate();

		</script>
	</body>
</html>
