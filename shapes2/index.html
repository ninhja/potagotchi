<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<!-- <link rel=stylesheet href="css/base.css"/> -->
		<title>Pot Shapes</title>
		<style>
			@font-face {
				font-family: 'inconsolata';
				src: url('files/inconsolata.woff') format('woff');
				font-weight: normal;
				font-style: normal;
			}

			body {
				margin:0;
				font-family: 'inconsolata';
				font-size: 18px;
				line-height: 18px;
				background-color: #ffffff;
				margin: 0px;
				overflow: hidden;
			}

			canvas {
				width: 100%;
				height: 100%;
				background-color: #FA8072;
		 }

		</style>
	</head>
	<body>

		<script src="build/three.js"></script>
		<script src='examples/js/libs/dat.gui.min.js'></script>
		<script src="examples/js/controls/OrbitControls.js"></script>
		<script src="examples/js/controls/DragControls.js"></script>
		<script src="examples/js/controls/TransformControls.js"></script>
		<script src="examples/js/exporters/STLExporter.js"></script>
		<script src="PQueue.js"></script>
		<script type="module">

			import CSG from "./CSGMesh.js"

			// Global control variables
			var gui, scene, camera, renderer, controls, exporter, sunControl;

			// light variables
			var light;
			var sun;
			var innerSun;
			var sunPosition;

			// Planter variables
			var root; // the base Object3D shape of the planter.
			var geometry; // the geometry of the root and its children:
										//{BoxGeometry, CylinderGeometry, SphereGeometry, etc.}
			var geomType = 'cube'; // a String that tells you the type of geometry
			var material = new THREE.MeshLambertMaterial( {color: 0x69ff00} ); //0x69ff00 0x47ff00
			var wallThickness = 1.5;
			var plantQueue;

			function init() {

				// SCENE
				scene = new THREE.Scene();

				// exporter
				exporter = new THREE.STLExporter();

				// CAMERA
				var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
				var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
				camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR );
				camera.position.set(60, 170, 0 );
				scene.add( camera );

				// RENDERER
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
				document.body.appendChild( renderer.domElement );

				// ORBIT CONTROLS
				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 0, 0 );
				controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				controls.dampingFactor = 0.35;
				controls.screenSpacePanning = false;
				controls.maxDistance = 500;
				controls.maxPolarAngle = Math.PI / 2;
				controls.update();
				controls.addEventListener( 'change', render );

				// AXES HELPER
				// The X axis is red. The Y axis is green. The Z axis is blue.
				var axes = new THREE.AxesHelper(200);
				scene.add(axes);

				// LIGHTS
				light = new THREE.PointLight( 0xffffff, 1, 0 );
				light.position.set( 0, 80, 40 );
				light.castShadow = true;
				light.shadow.radius = 8;
				scene.add( light );
				scene.add( new THREE.AmbientLight( 0xffffff, 0.8 ) ); // I add AmbientLight to lighten the shadows

				// SUN
				var sunGeometry = new THREE.SphereGeometry( 7, 16, 16 );
				var innerSunGeometry = new THREE.SphereGeometry( 5, 16, 16 );
				var sunMaterial = new THREE.MeshBasicMaterial( { color: 0xffee71, transparent: true, opacity: 0.5 } );
				var innerSunMaterial = new THREE.MeshBasicMaterial( { color: 0xffd600 } );
				sun = new THREE.Mesh( sunGeometry, sunMaterial );
				innerSun = new THREE.Mesh( innerSunGeometry, innerSunMaterial );
				sun.position.set( 0, 80, 40 );
				scene.add(sun);
				sun.add(innerSun);
				sun.add(light);

				// SUN CONTROL (change position of sun by dragging and dropping)
				sunControl = new THREE.TransformControls( camera, renderer.domElement );
				sunControl.addEventListener( 'change', render );
				sunControl.addEventListener( 'dragging-changed', function ( event ) {
					controls.enabled = ! event.value;
				} );
				sunControl.attach( sun );
				sunControl.setSize( 0.75 );
				sunControlToggle(false);
				scene.add( sunControl );

				// FLOOR
				var floorMaterial = new THREE.MeshLambertMaterial( { color: 0x2DA100 } );
				var floorGeometry = new THREE.CylinderGeometry(70, 70, 2, 64, 64);
				var floor = new THREE.Mesh(floorGeometry, floorMaterial);
				floor.position.y = -6;
				floor.receiveShadow = true;
				scene.add(floor);

				// SKYBOX/FOG 	#FA8072
				var skyBoxGeometry = new THREE.BoxGeometry( 800, 800, 800 );
				var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0xa7d3ff, side: THREE.BackSide } );
				var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
				scene.add(skyBox);

				// RESIZE WINDOW
				window.addEventListener( 'resize', function () {
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
					renderer.setSize( window.innerWidth, window.innerHeight );
				}, false );

				// GUI
				setupDatGui();

				// creating Priority queue for planter
				plantQueue = new PriorityQueue();
			}

			// creates the root of the pot (the base shape)
			// args: geom (type = String) is the seed shape that the user specified in gui.
			function createRoot() {
				// create the root object. This will be the base of the planter.
				root = new Pot(geomType, material, wallThickness);
				root.setPosition( 0, 0, 0 );
				plantQueue.enqueue(root, calcPriority(root));
			}

			// creates the child shape to add to its parent shape
	    function createChild(parent) {
				var child = new Pot(geomType, material, wallThickness, parent);
	      var parentSize = parent.getSize();
				var parentPos = parent.getPosition();

	      var validPositions = allPossibleChildPositions(parentPos, parentSize);
	      var new_pos = getRandomChildPos(validPositions);
	      child.setPosition(new_pos.x, new_pos.y, new_pos.z);

	      plantQueue.enqueue(child, calcPriority(child));
	    }

			function calcPriority(child) {
				var priority;
				// closer it is, higher in priority queue
				priority += calcDistance(child.outerMesh, sun);
				return priority;
			}

			function calcDistance(object1, object2) {
				var x1 = object1.position.x,
						x2 = object2.position.x,
						y1 = object1.position.y,
						y2 = object2.position.y,
						z1 = object1.position.z,
						z2 = object2.position.z;
				var dist = Math.sqrt( Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2) + Math.pow((z1-z2), 2));
				return dist;
			}

			function getRandomInt(pos, dim) {
				var diff = dim / 4;
				var min = pos - (dim / 2);
				var max = pos;
				// calculate random number from range(min,max)
				var n = Math.floor((Math.random() * (max - min + 1)) + min);
				// translate value if falls within this range to get rightmost 1/3 of shape
				if ((n >= pos - diff) && (n <= pos + diff)) {
					n += dim / 2;
				}
				return n;
			}

			function getRandomY(pos, dim) {
				var min = pos;
				var max = pos + dim;
				// calculate random number from range(min,max)
				var n = Math.floor((Math.random() * (max - min + 1)) + min);
				return n;
			}

			// grows plan in xz axis
			function getRandomChildPos2D(pos, dim) {
				var solutions = [];
				var pt = new THREE.Vector3( pos.x, pos.y, pos.z );
				var x1, z1;
				for (x1 = pt.x - dim; x1 < pt.x + dim; x1++) {
						for(z1 = pt.z - dim; z1 < pt.z + dim; z1++) {
							var new_pt = new THREE.Vector3( x1, pt.y, z1 );
							// distance between position and new point
							var dist = pt.distanceTo(new_pt);
							if (dist <= (dim / 2)) {
								solutions.push(new_pt);
								// console.log("x:" + new_pt.x + "y:" + new_pt.y + "z:" + new_pt.z);
							}
						}
					}
				return getRandomChildPos(solutions);
				//child.position.set(new_pos.x, new_pos.y, new_pos.z);
			}

			// chooses random child position from list of all possible positions
			function getRandomChildPos(positions) {
				var i = Math.floor((Math.random() * positions.length));
				return positions[i];
			}

			function allPossibleChildPositions(pos, dim) {
				var solutions = [];
				var pt = new THREE.Vector3( pos.x, pos.y, pos.z );
				var x1, y1, z1;
				for (x1 = pt.x - dim; x1 < pt.x + dim; x1++) {
					for (y1 = pt.y - dim; y1 < pt.y + dim; y1++) {
	  				for(z1 = pt.z - dim; z1 < pt.z + dim; z1++) {
							var new_pt = new THREE.Vector3( x1, y1, z1 );
							// distance between position and new point
							var dist = pt.distanceTo(new_pt);
							if (dist <= (dim / 2)) {
								solutions.push(new_pt);
								// console.log("x:" + new_pt.x + "y:" + new_pt.y + "z:" + new_pt.z);
							}
						}
					}
				}
				return solutions;
			}

			// 3D PRINTING FUNCTIONS

			function exportSTL(mesh) {
				var result = exporter.parse( mesh );
		    saveString( result, 'pot.stl' );
			}

			var link = document.createElement( 'a' );
			link.style.display = 'none';
			document.body.appendChild( link );

			function save( blob, filename ) {
				link.href = URL.createObjectURL( blob );
				link.download = filename;
				link.click();
			}

			function saveString( text, filename ) {
				save( new Blob( [ text ], { type: 'text/plain' } ), filename );
			}

			// SETTING UP GUI

			function setupDatGui() {
				gui = new dat.GUI({name: 'My GUI'});

				// Options to be added to the GUI
				var options = {
				  seedShape: 'cube',
					createRoot: function() {
						if (root != null) {
							alert("You already have a planter growing! Uproot it to plant a new one.");
						} else {
							createRoot();

						}
				  },
				  addChild: function() {
						if (root == null) {
							alert("Plant your seed first!");
						} else {
							createChild(plantQueue.dequeue().element);
						}
				  },
					uprootPlanter: function() {
						scene.remove(root);
						root = null;
						plantQueue.items = []
					},
					sunPosition: {
						moveEnabled: false,
						sunX: 0,
						sunY: 80,
						sunZ: 40
					},
					exportSTL: function() {
						if (root == null) {
							alert("Plant your seed first!");
						} else {
							console.log(root.groupedMeshes.children);
							exportSTL(root.groupedMeshes);
						}
					}
				};

				var seedShape = gui.add(options, 'seedShape', [ 'cube', 'cylinder', 'sphere' ] ).name('Seed shape').onChange(function (value) {
				  geomType = value;
				});

				gui.add(options, 'createRoot').name('Plant a new seed');
				gui.add(options, 'addChild').name('Grow planter');
				gui.add(options, 'uprootPlanter').name('Uproot planter');
				// gui.add(options, 'sunPosition', 0, 360).name('Move sun');

				gui.add(options.sunPosition, 'moveEnabled').name('Move sun').onChange(function (value) {
				  sunControlToggle(value);
				});

				gui.add(options, 'exportSTL').name('Print');


			}

			function sunControlToggle( bool ) {
				sunControl.showX = bool;
				sunControl.showY = bool;
				sunControl.showZ = bool;
			}

			function animate() {
				requestAnimationFrame( animate );
				controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
				render();
			}

			function render() {
				renderer.render( scene, camera );
			}

			function alertMessage( message ) {
				alert( message );
			}


			class Pot {
			  constructor(_geomType, _material, _wallThickness, _parent = null)
			  {
			    this.geomType = _geomType;
			    this.material = _material;
			    this.wallThickness = _wallThickness;
					this.parent = _parent;

			    // choose the type of geometry, based on what the user specified in gui
			    this.outerGeom = (function(geomType) {
			      switch(geomType) {
			        case 'cube':
			          return new THREE.BoxGeometry( 10, 10, 10 );
			        case 'cylinder':
			          return new THREE.CylinderGeometry( 10, 10, 10, 32, 32 );
			        case 'sphere':
			          return new THREE.SphereGeometry( 10, 32, 32);
			      }
			    })(this.geomType);
			    this.outerMesh = new THREE.Mesh(this.outerGeom, this.material);

			    this.innerGeom;
			    this.innerMesh;

			    this.bottomPlateGeom;
			    this.bottomPlateMesh;

			    this.groupedMeshes = new THREE.Group();

			    this.groupedMeshes.castShadow = true; //default is false
			    this.groupedMeshes.receiveShadow = false; //default

			    this.shelledMesh;
			    this.shell();
			  }

				getPosition() {
			    return this.outerMesh.position;
			  }

			  setPosition(x, y, z) {
			    this.groupedMeshes.position.set(x, y, z);
			  }

			  // adds the child shape to its parent, then adds child to scene
			  addChild(parent, child) {
			    parent.add(child);
			  }

			  shell() {
			    this.innerGeom = this.getInnerGeom(this.geomType);
			    this.innerMesh = new THREE.Mesh(this.innerGeom);
			    this.shelledMesh = this.doCSG( this.outerMesh, this.innerMesh, 'subtract', this.material);

			    this.groupedMeshes.add(this.shelledMesh);
			    this.groupedMeshes.add(this.bottomPlateMesh);

					if (this.parent == null) {
						scene.add(this.groupedMeshes);
					} else {
						this.parent.groupedMeshes.add(this.groupedMeshes);
						console.log("added to children hehehe");
					}
			  }

			  getInnerGeom(geomType) {
			    var outerSize = this.getSize();
			    var innerSize;
			    var bottomPlate;

			    switch(geomType) {
			      case 'cube':
			        // innerSize = outerSize - (2 * this.wallThickness);
			        innerSize = outerSize - (2 * this.wallThickness);

			        this.bottomPlateGeom = new THREE.CubeGeometry( outerSize, this.wallThickness, outerSize );
			        this.bottomPlateMesh = new THREE.Mesh(this.bottomPlateGeom, this.material);
			        this.bottomPlateMesh.position.set(this.outerMesh.position.x, this.outerMesh.position.y, this.outerMesh.position.z);
			        this.bottomPlateMesh.position.setY(this.outerMesh.position.y - (outerSize/2) + (this.wallThickness/2));

			        return new THREE.CubeGeometry( innerSize, 50, innerSize );
			      case 'cylinder':
			        innerSize = outerSize - this.wallThickness;

			        this.bottomPlateGeom = new THREE.CylinderGeometry( outerSize, outerSize, this.wallThickness, 32, 32 );
			        this.bottomPlateMesh = new THREE.Mesh(this.bottomPlateGeom, this.material);
			        this.bottomPlateMesh.position.set(this.outerMesh.position.x, this.outerMesh.position.y, this.outerMesh.position.z);
			        this.bottomPlateMesh.position.setY(this.outerMesh.position.y - (outerSize/2) + (this.wallThickness/2));

			        return new THREE.CylinderGeometry( innerSize, innerSize, 50, 32, 32 );
			      case 'sphere':
			        innerSize = outerSize - this.wallThickness*2;

			        this.bottomPlateGeom = new THREE.CylinderGeometry( innerSize, innerSize, this.wallThickness, 32, 32)
			        this.bottomPlateMesh = new THREE.Mesh(this.bottomPlateGeom, this.material);
			        this.bottomPlateMesh.position.set(this.outerMesh.position.x, this.outerMesh.position.y, this.outerMesh.position.z);
			        this.bottomPlateMesh.position.setY(this.outerMesh.position.y - (outerSize) + (this.wallThickness*1.5));

			        return new THREE.CylinderGeometry( innerSize, innerSize, 50, 32, 32);
			    }
			  }

			  doCSG(a,b,op,mat){
			     var bspA = CSG.fromMesh( a );
			     var bspB = CSG.fromMesh( b );
			     var bspC = bspA[op]( bspB );
			     var result = CSG.toMesh( bspC, a.matrix );
			     result.material = mat;
			     result.castShadow  = result.receiveShadow = true;
			     return result;
			  }

			  // helper function for creating a new object.
			  // turns the solid geometry into a shell, with specified wall thickness
			  getSize() {
			    switch(this.geomType) {
			      case 'cube':
			        return this.outerGeom.parameters.width;
			      case 'cylinder':
			        return this.outerGeom.parameters.radiusTop;
			      case 'sphere':
			        return this.outerGeom.parameters.radius;
			    }
			  }
			}

			init();
			animate();

		</script>
	</body>
</html>
