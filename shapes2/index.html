<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<!-- <link rel=stylesheet href="css/base.css"/> -->
		<title>Pot Shapes</title>
		<style>
			@font-face {
				font-family: 'inconsolata';
				src: url('files/inconsolata.woff') format('woff');
				font-weight: normal;
				font-style: normal;
			}

			body {
				margin:0;
				font-family: 'inconsolata';
				font-size: 18px;
				line-height: 18px;
				background-color: #ffffff;
				margin: 0px;
				overflow: hidden;
			}

			canvas {
				width: 100%;
				height: 100%;
				background-color: #FA8072;
		 }

		</style>
	</head>
	<body>

		<script src="build/three.js"></script>
		<script src='examples/js/libs/dat.gui.min.js'></script>
		<script src="examples/js/controls/OrbitControls.js"></script>
		<script src="examples/js/exporters/STLExporter.js"></script>
		<script src="ThreeCSG.js"></script>
		<script src="PQueue.js"></script>
		<script type="module">

			import CSG from "./CSGMesh.js"

			// Global control variables
			var gui, scene, camera, renderer, controls, exporter;

			// light variables
			var light;
			var sun;
			var sunPosition;

			// Planter variables
			var root; // the base Object3D shape of the planter.
			var geometry; // the geometry of the root and its children:
										//{BoxGeometry, CylinderGeometry, SphereGeometry, etc.}
			var geomType; // a String that tells you the type of geometry
			var material = new THREE.MeshLambertMaterial( {color: 0x69ff00} ); //0x69ff00 0x47ff00
			var plantQueue;

			function init() {

				// SCENE
				scene = new THREE.Scene();

				// exporter
				exporter = new THREE.STLExporter();

				// CAMERA
				var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
				var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
				camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR );
				camera.position.set(60, 170, 0 );
				scene.add( camera );

				// RENDERER
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
				document.body.appendChild( renderer.domElement );

				// ORBIT CONTROLS
				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 0, 0 );
				controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				controls.dampingFactor = 0.35;
				controls.screenSpacePanning = false;
				controls.maxDistance = 500;
				controls.maxPolarAngle = Math.PI / 2;

				// AXES HELPER
				// The X axis is red. The Y axis is green. The Z axis is blue.
				var axes = new THREE.AxesHelper(400);
				scene.add(axes);

				// LIGHTS
				var light = new THREE.PointLight( 0xffffff, 1, 0 );
				light.position.set( 0, 80, 40 );
				light.castShadow = true;
				light.shadow.radius = 8;
				scene.add( light );
				scene.add( new THREE.AmbientLight( 0xffffff, 0.8 ) ); // I add AmbientLight to lighten the shadows

				// SUN
				var sunGeometry = new THREE.SphereGeometry( 7, 16, 16 );
				var innerSunGeometry = new THREE.SphereGeometry( 5, 16, 16 );
				var sunMaterial = new THREE.MeshBasicMaterial( { color: 0xffee71, transparent: true, opacity: 0.5 } );
				var innerSunMaterial = new THREE.MeshBasicMaterial( { color: 0xffd600 } );
				sun = new THREE.Mesh( sunGeometry, sunMaterial );
				var innerSun = new THREE.Mesh( innerSunGeometry, innerSunMaterial );
				sun.position.set( 0, 80, 40 );
				innerSun.position.set( 0, 80, 40 );
				scene.add(sun);
				scene.add(innerSun);

				// FLOOR
				// var floorTexture = new THREE.ImageUtils.loadTexture( 'images/checkerboard.jpg' );
				// floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
				// floorTexture.repeat.set( 10, 10 );
				// var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
				var floorMaterial = new THREE.MeshLambertMaterial( { color: 0x2DA100 } );
				var floorGeometry = new THREE.CylinderGeometry(50, 50, 2, 64, 64);
				var floor = new THREE.Mesh(floorGeometry, floorMaterial);
				floor.position.y = -6;
				floor.receiveShadow = true;
				scene.add(floor);

				// SKYBOX/FOG 	#FA8072
				var skyBoxGeometry = new THREE.BoxGeometry( 800, 800, 800 );
				var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0xa7d3ff, side: THREE.BackSide } );
				var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
				scene.add(skyBox);
				// scene.fog = new THREE.FogExp2( 0x75baff, 0.007 );

				// RESIZE WINDOW
				window.addEventListener( 'resize', function () {
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
					renderer.setSize( window.innerWidth, window.innerHeight );
				}, false );

				// GUI
				setupDatGui();

				// var meshA = new THREE.Mesh(new THREE.BoxGeometry(100,100,100), material);
				// var meshB = new THREE.Mesh(new THREE.BoxGeometry(60, 60, 200), material);
				//
				// meshB.position.add(new THREE.Vector3( 200, 200, 200));
				// var meshC = doCSG( meshA,meshB, 'union',meshA.material);
				// scene.add(meshC);

				// creating Priority queue for planter
				plantQueue = new PriorityQueue();

			}

			function doCSG(a,b,op,mat){
			   var bspA = CSG.fromMesh( a );
			   var bspB = CSG.fromMesh( b );
			   var bspC = bspA[op]( bspB );
			   var result = CSG.toMesh( bspC, a.matrix );
			   result.material = mat;
			   result.castShadow  = result.receiveShadow = true;
			   return result;
			}

			// creates the root of the pot (the base shape)
			// args: geom (type = String) is the seed shape that the user specified in gui.
			function createRoot( geom ) {
				geomType = geom;

				// choose the type of geometry, based on what the user specified in gui
				geometry = (function(geomType) {
					switch(geomType) {
						case 'cube':
							return new THREE.BoxGeometry( 10, 10, 10 );
						case 'cylinder':
							return new THREE.CylinderGeometry( 10, 10, 10, 32, 32 );
						case 'sphere':
							return new THREE.SphereGeometry( 10, 32, 32);
					}
				})(geomType);

				// create the root object. This will be the base of the planter.
				root = new THREE.Mesh( geometry, material );
				root.position.set( 0, 0, 0 );
				root.castShadow = true; //default is false
				root.receiveShadow = false; //default
				plantQueue.enqueue(root, calcPriority(root));
				scene.add(root);
				// shell(root, 2);
			}

			// creates the child shape to add to its parent shape
			function createChild(parent) {
				var child = new THREE.Mesh( geometry, material );
				var parentSize = getSize(parent);

				// position the child in a random so that it overlaps with its parent.
				child.position.set(getRandomInt(parent.position.x, parentSize),
													 getRandomInt(parent.position.y, parentSize),
													 getRandomInt(parent.position.z, parentSize));
				child.castShadow = true; //default is false
				child.receiveShadow = false; //default
				addChild(parent, child);
				plantQueue.enqueue(child, calcPriority(child));
				// shell(child, 2);
			}

			// adds the child shape to its parent, then adds child to scene
			function addChild(parent, child) {
				parent.add(child);
			}

			function calcPriority(child) {
				var priority;
				// distance from child to sun, inverse of
				// closer it is, higher priority
				priority += 1/calcDistance(child, sun);
				return priority;
			}

			function calcDistance(point1, point2) {
				var x1 = point1.position.x,
						x2 = point2.position.x,
						y1 = point1.position.y,
						y2 = point2.position.y,
						z1 = point1.position.z,
						z2 = point2.position.z;
				var dist = Math.sqrt( Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2) + Math.pow((z1-z2), 2));
				return dist;
			}

			function shell(object, wallThickness) {
				var outerSize = getSize(object);
				var innerGeom = (function(geomType) {
					var innerSize;
					switch(geomType) {
						case 'cube':
							innerSize = outerSize - (2 * wallThickness)
							return new THREE.SphereGeometry( innerSize, innerSize, innerSize );
						case 'cylinder':
							innerSize = outerSize - wallThickness
							return new THREE.SphereGeometry( innerSize, innerSize, innerSize, 32, 32 );
						case 'sphere':
							innerSize = outerSize - wallThickness
							return new THREE.SphereGeometry( innerSize, 32, 32);
					}
				})(geomType);
				var innerGeom = new THREE.SphereGeometry( outerSize - wallThickness*2, 32, 32);
				// var outerMesh = new THREE.Mesh(object.geometry, material);
				var innerMesh = new THREE.Mesh(innerGeom, material);

				var objectX = object.position.x;
				var objectY = object.position.y;
				var objectZ = object.position.z;
				// innerMesh.position.set(objectX+100, objectY + (wallThickness*2) + 50, objectZ);
				innerMesh.position.add(new THREE.Vector3( objectX, objectY + wallThickness*2 + 40, objectZ));

				// var shelledMesh = doCSG(innerMesh, object, 'subtract', material);
				// scene.add(innerMesh);
				// scene.add(outerMesh);
				// scene.add(object);
				// scene.add(shelledMesh);

			}

			// helper function for creating a new object.
			// turns the solid geometry into a shell, with specified wall thickness
			function getSize(object) {
				switch(geomType) {
					case 'cube':
						return object.geometry.parameters.width;
					case 'cylinder':
						return object.geometry.parameters.radiusTop;
					case 'sphere':
						return object.geometry.parameters.radius;
				}
			}

			// position (x), length of geometry
			function getRandomInt(pos, dim) {
				var diff = dim / 3; // add 1 if inclusive
				var min = pos - (dim / 2);
				var max = pos + (dim / 6);
				// calculate random number from range(min,max)
				var n = Math.floor((Math.random() * (max - min + 1)) + min);
				// translate value if falls within this range to get rightmost 1/3 of shape
				if ((n >= pos - (dim / 6)) && (n <= pos + (dim / 6))) {
					n += diff;
				}
				return n;
			}

			function exportSTL(mesh) {
				var result = exporter.parse( mesh );
		    saveString( result, 'pot.stl' );
			}

			var link = document.createElement( 'a' );
			link.style.display = 'none';
			document.body.appendChild( link );

			function save( blob, filename ) {
				link.href = URL.createObjectURL( blob );
				link.download = filename;
				link.click();
			}

			function saveString( text, filename ) {
				save( new Blob( [ text ], { type: 'text/plain' } ), filename );
			}

			function setupDatGui() {
				gui = new dat.GUI({name: 'My GUI'});

				// Options to be added to the GUI
				var options = {
				  seedShape: 'cube',
					createRoot: function() {
						if (root != null) {
							alert("You already have a planter growing! Uproot it to plant a new one.");
						} else {
							createRoot(options.seedShape);
						}
				  },
				  addChild: function() {
						if (root == null) {
							alert("Plant your seed first!");
						} else {
							createChild(plantQueue.front());
						}
				  },
					uprootPlanter: function() {
						scene.remove(root);
						root = null;
					},
					exportSTL: function() {
						if (root == null) {
							alert("Plant your seed first!");
						} else {
							exportSTL(root);
						}
					}
				};

				// DAT.GUI Related Stuff
				// var seeds = gui.addFolder('Seed Shape');
				// seeds.add(options.seeds, 'cube').listen();
				// seeds.add(options.seeds, 'sphere').listen();
				// seeds.add(options.seeds, 'cylinder').listen();
				// seeds.open();

				var seedShape = gui.add(options, 'seedShape', [ 'cube', 'cylinder', 'sphere' ] ).name('Seed shape');

				gui.add(options, 'createRoot').name('Plant a new seed');
				gui.add(options, 'addChild').name('Grow planter');
				gui.add(options, 'uprootPlanter').name('Uproot planter');
				gui.add(options, 'exportSTL').name('Print')
			}

			function animate() {
				requestAnimationFrame( animate );
				controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
				render();
			}

			function render() {
				renderer.render( scene, camera );
			}

			function alertMessage( message ) {
				alert( message );
			}

			init();
			animate();

		</script>
	</body>
</html>
