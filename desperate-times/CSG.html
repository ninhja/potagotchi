<!doctype html>
<html lang="en">
<head>
	<title>Desperate times call for desperate measures</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel=stylesheet href="css/base.css"/>
</head>
<body>

<script src="js/Three58.js"></script>
<script src="js/Detector.js"></script>
<script src="js/Stats.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>
<script src="js/STLExporter.js"></script>
<script src='js/DAT.GUI.min.js'></script>
<script src="js/PQueue.js"></script>

<!-- Constructive Solid Geometry library by ChandlerPrall -->
<script src="js/ThreeCSG.js"></script>

<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
<script>
/*
	Three.js "tutorials by example"
	Author: Lee Stemkoski
	Date: July 2013 (three.js v58)
*/
// MAIN
// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();
// custom global variables
var cube;

// light variables
var light;
var sun;
var sunPosition;

// Planter variables
var root; // the base Object3D shape of the planter.
var geometry; // the geometry of the root and its children:
							//{BoxGeometry, CylinderGeometry, SphereGeometry, etc.}
var geomType; // a String that tells you the type of geometry
var material = new THREE.MeshLambertMaterial( {color: 0x69ff00} ); //0x69ff00 0x47ff00
var plantQueue;

init();
animate();
// FUNCTIONS
function init()
{
	// SCENE
	scene = new THREE.Scene();
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);
	camera.position.set(60, 170, 0 );

	// RENDERER
	// if ( Detector.webgl )
	// 	renderer = new THREE.WebGLRenderer( {antialias:true} );
	// else
	// 	renderer = new THREE.CanvasRenderer();
	renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );

	// SHADOWS
	// renderer.shadowMap.enabled = true;
	// renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

	// EVENTS
	THREEx.WindowResize(renderer, camera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
	// CONTROLS
	controls = new THREE.OrbitControls( camera, renderer.domElement );

	// STATS
	// stats = new Stats();
	// stats.domElement.style.position = 'absolute';
	// stats.domElement.style.bottom = '0px';
	// stats.domElement.style.zIndex = 100;
	// container.appendChild( stats.domElement );

	// LIGHT
	// var light = new THREE.PointLight(0xffffff);
	// light.position.set(0,250,0);
	// scene.add(light);
	var light = new THREE.PointLight( 0xffffff, 1, 0 );
	light.position.set( 0, 80, 40 );
	// light.castShadow = true;
	// light.shadow.radius = 8;
	scene.add( light );

	// spotlight for shadows
	var spotlight2 = new THREE.SpotLight(0xffffff);
	spotlight2.position.set(0, 80, 40);
	scene.add(spotlight2);
	spotlight2.shadowCameraVisible = true;
	spotlight2.shadowDarkness = 0.70;
	spotlight2.intensity = 2;
	spotlight2.castShadow = true;

	// SUN
	var sunGeometry = new THREE.SphereGeometry( 7, 16, 16 );
	var innerSunGeometry = new THREE.SphereGeometry( 5, 16, 16 );
	var sunMaterial = new THREE.MeshBasicMaterial( { color: 0xffee71, transparent: true, opacity: 0.5 } );
	var innerSunMaterial = new THREE.MeshBasicMaterial( { color: 0xffd600 } );
	var sun = new THREE.Mesh( sunGeometry, sunMaterial );
	var innerSun = new THREE.Mesh( innerSunGeometry, innerSunMaterial );
	sun.position.set( 0, 80, 40 );
	innerSun.position.set( 0, 80, 40 );
	scene.add(sun);
	scene.add(innerSun);

	// FLOOR
	var floorMaterial = new THREE.MeshLambertMaterial( { color: 0x2DA100 } );
	var floorGeometry = new THREE.CylinderGeometry(50, 50, 2, 64, 64);
	var floor = new THREE.Mesh(floorGeometry, floorMaterial);
	floor.position.y = -6;
	floor.receiveShadow = true;
	scene.add(floor);

	// SKYBOX/FOG
	var skyBoxGeometry = new THREE.CubeGeometry( 800, 800, 800 );
	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0xa7d3ff, side: THREE.BackSide } );
	var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
	scene.add(skyBox);

	////////////
	// CUSTOM //
	////////////

	// GUI
	setupDatGui();

	// creating Priority queue for planter
	plantQueue = new PriorityQueue();

	// helloWorld();
	var meshA = new THREE.Mesh(new THREE.CubeGeometry(10,10,10), material);
	var meshB = new THREE.Mesh(new THREE.CubeGeometry(9,9,50));
	// meshB.position.add(new THREE.Vector3( 10,10,10));
	meshB.position.add(new THREE.Vector3( 5, 5, 5));
	meshA.castShadow = true;
	scene.add(meshA);
	scene.add(meshB);
}

function helloWorld() {
	var materialNormal = new THREE.MeshNormalMaterial();

	var cubeGeometry = new THREE.CubeGeometry( 100, 100, 100, 1, 1, 1 );
	var cubeMesh = new THREE.Mesh( cubeGeometry );
	var cubeBSP = new ThreeBSP( cubeMesh );

	var sphereGeometry = new THREE.SphereGeometry( 60, 32, 32 );
	var sphereMesh = new THREE.Mesh( sphereGeometry );
	var sphereBSP = new ThreeBSP( sphereMesh );

	// Example #1 - Cube subtract Sphere
	var newBSP = cubeBSP.subtract( sphereBSP );
	var newMesh = newBSP.toMesh( materialNormal );
	newMesh.position.set(-180, 60, 0);
	scene.add( newMesh );
	// Example #2 - Sphere subtract Cube
	var newBSP = sphereBSP.subtract( cubeBSP );
	var newMesh = newBSP.toMesh( materialNormal );
	newMesh.position.set(180, 60, 0);
	scene.add( newMesh );

	// Example #3 - Cube union Sphere
	var newBSP = sphereBSP.union( cubeBSP );
	var newMesh = newBSP.toMesh( materialNormal );
	newMesh.position.set(70, 60, -120);
	scene.add( newMesh );
	// Example #4 - Cube intersect Sphere
	var newBSP = sphereBSP.intersect( cubeBSP );
	var newMesh = newBSP.toMesh( materialNormal );
	newMesh.position.set(-70, 60, -120);
	scene.add( newMesh );
}

/// PLANTER FUNCTIONS

// creates the root of the pot (the base shape)
// args: geom (type = String) is the seed shape that the user specified in gui.
function createRoot( geom ) {
	geomType = geom;

	// choose the type of geometry, based on what the user specified in gui
	geometry = (function(geomType) {
		switch(geomType) {
			case 'cube':
				return new THREE.CubeGeometry( 10, 10, 10 );
			case 'cylinder':
				return new THREE.CylinderGeometry( 10, 10, 10, 32, 32 );
			case 'sphere':
				return new THREE.SphereGeometry( 10, 32, 32);
		}
	})(geomType);

	// create the root object. This will be the base of the planter.
	root = new THREE.Mesh( geometry, material );
	root.position.set( 0, 0, 0 );
	// root.castShadow = true; //default is false
	// root.receiveShadow = false; //default
	plantQueue.enqueue(root, calcPriority(root));
	scene.add(root);

	// shell(root, 2);
}

// creates the child shape to add to its parent shape
function createChild(parent) {
	var child = new THREE.Mesh( geometry, material );
	var parentSize = getSize(parent);

	// position the child in a random so that it overlaps with its parent.
	child.position.set(getRandomInt(parent.position.x, parentSize),
										 getRandomInt(parent.position.y, parentSize),
										 getRandomInt(parent.position.z, parentSize));
	// child.castShadow = true; //default is false
	// child.receiveShadow = false; //default
	addChild(parent, child);
	plantQueue.enqueue(child, calcPriority(child));
	// shell(child, 2);
}

// adds the child shape to its parent, then adds child to scene
function addChild(parent, child) {
	parent.add(child);
}

function calcPriority(child) {
	var priority;
	// distance from child to sun, inverse of
	// closer it is, higher priority
	priority += 1/calcDistance(child, sun);
	return priority;
}

function calcDistance(point1, point2) {
	var x1 = point1.position.x,
			x2 = point2.position.x,
			y1 = point1.position.y,
			y2 = point2.position.y,
			z1 = point1.position.z,
			z2 = point2.position.z;
	var dist = Math.sqrt( Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2) + Math.pow((z1-z2), 2));
	return dist;
}

function shell(object, wallThickness) {
	var outerSize = getSize(object);
	var innerObject = (function(geomType) {
		var innerSize;
		switch(geomType) {
			case 'cube':
				innerSize = outerSize - (2 * wallThickness)
				return new THREE.BoxGeometry( innerSize, innerSize, innerSize );
			case 'cylinder':
				innerSize = outerSize - wallThickness
				return new THREE.CylinderGeometry( innerSize, innerSize, innerSize, 32, 32 );
			case 'sphere':
				innerSize = outerSize - wallThickness
				return new THREE.SphereGeometry( innerSize, 32, 32);
		}
	})(geomType);

	var outerMesh = new THREE.Mesh(object.geometry);
	var outerBSP = new ThreeBSP(outerMesh);

	var innerMesh = new THREE.Mesh(innerObject);
	var innerBSP = new ThreeBSP(innerMesh);

	var objectX = object.position.x;
	var objectY = object.position.y;
	var objectZ = object.position.z;
	innerMesh.position.set(objectX, objectY + wallThickness, objectZ);

	var shelledBSP = outerBSP.subtract(outerBSP.intersect(innerBSP));
	var shelledMesh = shelledBSP.toMesh(material);

	scene.add(shelledMesh);
	// return shelledMesh
}

// helper function for creating a new object.
// turns the solid geometry into a shell, with specified wall thickness
function getSize(object) {
	switch(geomType) {
		case 'cube':
			return object.geometry.parameters.width;
		case 'cylinder':
			return object.geometry.parameters.radiusTop;
		case 'sphere':
			return object.geometry.parameters.radius;
	}
}

// position (x), length of geometry
function getRandomInt(pos, dim) {
	var diff = dim / 4; // add 1 if inclusive
	var min = pos - (dim / 2);
	var max = pos;
	// calculate random number from range(min,max)
	var n = Math.floor((Math.random() * (max - min + 1)) + min);
	// translate value if falls within this range to get rightmost 1/3 of shape
	if ((n >= pos - diff) && (n <= pos + diff)) {
		n += dim / 2;
	}
	return n;
}

function setupDatGui() {
	gui = new dat.GUI({name: 'My GUI'});

	// Options to be added to the GUI
	var options = {
		seedShape: 'cube',
		createRoot: function() {
			if (root != null) {
				alert("You already have a planter growing! Uproot it to plant a new one.");
			} else {
				createRoot(options.seedShape);
				console.log(plantQueue.printPQueue());
			}
		},
		addChild: function() {
			if (root == null) {
				alert("Plant your seed first!");
			} else {
				// nodeToGrow = plantQueue.dequeue();
				var nextNodeToGrow = plantQueue.front().element;
				while (nextNodeToGrow.children.length > 1) {
					plantQueue.dequeue();
					nextNodeToGrow = plantQueue.front().element;
				}
				createChild(plantQueue.front().element);
				// plantQueue.enqueue(plantQueue.enqueue());
			}
		},
		uprootPlanter: function() {
			scene.remove(root);
			root = null;
			plantQueue.items = []
		},
		exportSTL: function() {
			if (root == null) {
				alert("Plant your seed first!");
			} else {
				exportSTL(root);
			}
		}
	};

	// DAT.GUI Related Stuff
	// var seeds = gui.addFolder('Seed Shape');
	// seeds.add(options.seeds, 'cube').listen();
	// seeds.add(options.seeds, 'sphere').listen();
	// seeds.add(options.seeds, 'cylinder').listen();
	// seeds.open();

	var seedShape = gui.add(options, 'seedShape', [ 'cube', 'cylinder', 'sphere' ] ).name('Seed shape');

	gui.add(options, 'createRoot').name('Plant a new seed');
	gui.add(options, 'addChild').name('Grow planter');
	gui.add(options, 'uprootPlanter').name('Uproot planter');
	gui.add(options, 'exportSTL').name('Print')
}

function animate()
{
  requestAnimationFrame( animate );
	render();
	update();
}
function update()
{
	if ( keyboard.pressed("z") )
	{
		// do something
	}

	controls.update();
	stats.update();
}
function render()
{
	renderer.render( scene, camera );
}
</script>

</body>
</html>
